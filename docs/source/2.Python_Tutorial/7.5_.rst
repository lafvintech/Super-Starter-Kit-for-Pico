7.5.Cloud Player @MQTT
=======================
Message Queuing Telemetry Transport (MQTT) is a simple messaging protocol. It is also the most common messaging protocol for the Internet of Things (IoT).

MQTT protocols define the way IoT devices transfer data. They are event-driven and interconnected using the Pub/Sub model. The sender (Publisher) and the receiver (Subscriber) communicate via Topics. A device publishes a message on a specific topic, and all devices subscribed to that topic receive the message.

In this project, Pico W will act as a subscriber and receive the song name under the topic. If the song name is already in the code, Pico W will make the buzzer play the song.

Component List
^^^^^^^^^^^^^^^
- Raspberry Pi Pico W x1
- MicroUSB cable x1
- 830 Tie-Points Breadboard x1
- Resistor 1kΩ x1
- Transistor S8050 x1
- Passive Buzzer x1
- Li-po Charger Module x1
- Battery Holder x1
- Jumper Wire Several

Connect
^^^^^^^^^
.. warning:: 
    Make sure your Li-po Charger Module is connected as shown in the diagram. Otherwise, a short circuit will likely damage your battery and circuitry.

.. image:: img/3.connect/7.5.png
    
Seting MQTT
^^^^^^^^^^^
HiveMQ is an MQTT broker and client-based messaging platform that enables fast, efficient and reliable data transfer to IoT devices.

1. Open `HiveMQ Web Client <https://www.hivemq.com/demos/websocket-client/>`_ in your browser.
2. Connects the client to the default public proxy.

   .. image:: img/iot/mqtt-1.png

3. Click on **Add New Topic Subscription**.

   .. image:: img/iot/mqtt-2.png

4. Fill in the topics you want to follow and click **Subscribe**. The topics set here should be more personal to avoid getting messages from other users, and pay attention to case sensitive.

   .. image:: img/iot/mqtt-3.png


Code
^^^^^^^
Upload the ``play_music.py`` file under the path of ``Ultimate-Starter-Kit-for-Pico-W\iot`` to the Raspberry Pi Pico W.

.. note::

    * Open the ``7.5.py`` file under the path of ``Ultimate-Starter-Kit-for-Pico-W\Python\1.Project\iot`` or copy this code into Thonny, then click "Run Current Script" or simply press F5 to run it.

    * Don't forget to click on the "MicroPython (Raspberry Pi Pico)" interpreter in the bottom right corner. 
    
    * Before running the code, you need to make sure you have ``do_connect.py`` and ``secrets.py`` scripts in your Pico W, if not please refer to 8.1 Access to the Network to create them.

.. image:: img/4.software/7.5.png

Click “Run current script”, shell 会打印信息,你可以通过MQTT平台连接PICO W,然后发送歌曲名字使PICO W播放对应的歌曲

The following is the program code:

.. code-block:: python

    import machine
    import time

    # 7-segment display codes for digits 0-9, using hexadecimal to represent LED segments
    SEGCODE = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f]

    # Define pins for shift register communication (74HC595)
    sdi = machine.Pin(18, machine.Pin.OUT)   # Serial Data Input
    rclk = machine.Pin(19, machine.Pin.OUT)  # Register Clock (Latch)
    srclk = machine.Pin(20, machine.Pin.OUT) # Shift Register Clock

    # Initialize list to store 4 digit control pins
    placePin = []

    # Define control pins for each of the four digits (common anodes)
    pin = [10,13,12,11]  # Pin numbers for the 4-digit display
    for i in range(4):
        placePin.append(None)  # Reserve space in list
        placePin[i] = machine.Pin(pin[i], machine.Pin.OUT)  # Initialize pin as output

    # Function to select which digit (0-3) to display by controlling the common anode pins
    def pickDigit(digit):
        for i in range(4):
            placePin[i].value(1)  # Turn off all digits
        placePin[digit].value(0)  # Turn on the selected digit

    # Function to clear the display by sending '0x00' to the shift register
    def clearDisplay():
        hc595_shift(0x00)

    # Function to send data to the shift register (74HC595)
    def hc595_shift(dat):
        rclk.low()  # Pull latch low to prepare for data shifting
        time.sleep_us(200)  # Small delay for timing stability
        for bit in range(7, -1, -1):  # Loop through each bit (MSB first)
            srclk.low()  # Prepare to send the next bit
            time.sleep_us(200)
            value = 1 & (dat >> bit)  # Extract the current bit from the data
            sdi.value(value)  # Set the data line to the current bit value
            time.sleep_us(200)
            srclk.high()  # Pulse the shift clock to store the bit in the register
            time.sleep_us(200)
        time.sleep_us(200)
        rclk.high()  # Pulse the register clock to move the data to the output

    # Function to display a number on the 7-segment display
    # This function breaks down the number into its individual digits and displays them one at a time
    def display(num):
        pickDigit(0)  # Select the units place
        hc595_shift(SEGCODE[num % 10])  # Display units

        pickDigit(1)  # Select the tens place
        hc595_shift(SEGCODE[num % 100 // 10])  # Display tens

        pickDigit(2)  # Select the hundreds place
        hc595_shift(SEGCODE[num % 1000 // 100] + 0x80)  # Display hundreds (with decimal point)

        pickDigit(3)  # Select the thousands place
        hc595_shift(SEGCODE[num % 10000 // 1000])  # Display thousands

    # Initialize the tilt switch sensor on pin 16
    tilt_switch = machine.Pin(16, machine.Pin.IN)

    # Boolean flag to control whether the counting should continue
    count_flag = False

    # Interrupt handler for the tilt switch, toggles the counting flag on each trigger
    def shake(pin):
        global timeStart, count_flag
        count_flag = not count_flag  # Toggle the counting state
        if count_flag == True:
            timeStart = time.ticks_ms()  # Record the time when counting starts

    # Set up an interrupt on the tilt switch to detect shaking and call the shake() function
    tilt_switch.irq(trigger=machine.Pin.IRQ_RISING, handler=shake)

    # Initialize the count variable to zero
    count = 0

    # Main loop to continuously update the display based on the elapsed time since the tilt switch was triggered
    while True:
        if count_flag == True:
            count = int((time.ticks_ms() - timeStart) / 10)  # Calculate the count in tenths of a second
        display(count)  # Update the display with the current count


Phenomenon
^^^^^^^^^^^
.. video:: img/5.phenomenon/6.13.mp4
    :width: 100%